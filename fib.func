defn tail l = {
    case l of {
        [] -> { [] }
        [x:xs] -> { xs }
    }
}

defn zipWith f a b = { 
    case a of {
        [] -> {
            case b of {
                [] -> { [] }
                [bx:bs] -> { [] }
            }
        }
        [ax:as] -> {
            case b of {
                [] -> { [] }
                [bx:bs] -> { [f ax bx:zipWith f as bs] }
            }
        }
    }
}

defn add a b = { a + b }

defn if a b c = {
    case a of {
        True -> { b }
        False -> { c }
    }
}
defn indexInt l a = {
    case l of {
        [] -> { 0 }
        [x:xs] -> { if (a == 0) x (indexInt xs (a - 1))}
    }
}

defn fibonacci = { [0:1:zipWith add fibonacci (tail fibonacci)] }

defn charToInt c = {(charToNum c) - (charToNum '0')}
defn intToChar i = {numToChar (i + charToNum '0')}

defn stringToInt s t = {
    case s of {
        [] -> {t}
        [x: xs] -> {stringToInt xs (t * 10 + (charToInt x))}
    }
}

defn readInt = do {
    defn str <- {read}
    return {stringToInt str 0}
}

defn printInt x = do {
    case (x > 9) of {
        True -> do { { printInt(x / 10) } }
        False -> do { { print "" } }
    }
    {print [(intToChar (x % 10))]}
}

defn main = do { 
    defn a <- { readInt }
    { printInt (indexInt fibonacci a) }
}